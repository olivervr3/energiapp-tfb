\chapter{Desarrollo técnico}
\label{ch:desarrollo}

\section{Arquitectura del sistema: análisis de decisiones de diseño}

\subsection{Selección metodológica de la arquitectura}

La elección de la arquitectura del sistema constituye una decisión crítica que impacta directamente en la escalabilidad, mantenibilidad y experiencia de usuario de la plataforma. El proceso de selección se basó en un análisis comparativo de tres alternativas arquitectónicas principales, evaluadas mediante criterios cuantitativos y cualitativos.

\subsubsection{Análisis comparativo de arquitecturas candidatas}

\textbf{Arquitectura Monolítica Tradicional:}
Ventajas identificadas: simplicidad de despliegue, menor latencia inter-componentes, facilidad de debugging integral. 
Limitaciones críticas: acoplamiento fuerte entre módulos, escalabilidad limitada, tecnología única obligatoria.
Evaluación: Descartada debido a la naturaleza heterogénea de los módulos (web frontend, ML backend, simulación IoT) que requieren diferentes tecnologías optimizadas.

\textbf{Microservicios Distribuidos:}
Ventajas: escalabilidad independiente por servicio, flexibilidad tecnológica, resilencia ante fallos parciales.
Limitaciones: complejidad operacional elevada, overhead de comunicación inter-servicios, gestión compleja de transacciones distribuidas.
Evaluación: Considerada excesiva para el alcance actual del prototipo, aunque mantenida como evolución futura.

\textbf{Arquitectura Modular Híbrida (Seleccionada):}
Combina la simplicidad operacional de monolitos con la flexibilidad de microservicios mediante módulos semi-acoplados comunicados por APIs internas bien definidas. Esta aproximación permite evolución incremental hacia microservicios según las necesidades de escalabilidad.

\subsection{Justificación de decisiones tecnológicas críticas}

\subsubsection{Backend: Node.js vs alternativas}

La selección de Node.js como runtime del backend se basó en un análisis multi-criterio que consideró rendimiento, ecosistema de librerías, curva de aprendizaje y características específicas del dominio energético.

\textbf{Evaluación de rendimiento para cargas típicas:}
Los sistemas de gestión energética presentan patrones de carga caracterizados por: 
\begin{itemize}
    \item Múltiples conexiones concurrentes de dispositivos IoT (modelo I/O intensivo)
    \item Procesamiento de series temporales con baja complejidad computacional
    \item Requimientos de tiempo real para alertas y visualizaciones
\end{itemize}

Node.js demostró ventajas significativas en este perfil específico debido a su modelo de concurrencia basado en event-loop, que maneja eficientemente miles de conexiones WebSocket simultáneas con menor overhead de memoria comparado con modelos thread-per-connection (Java/C\#).

\textbf{Análisis del ecosistema de librerías especializadas:}
El ecosistema npm proporciona librerías maduras específicamente optimizadas para análisis de series temporales (InfluxDB drivers, chart.js integration) y protocolos IoT (MQTT.js, WebSocket libraries), reduciendo significativamente el tiempo de desarrollo versus implementaciones from-scratch en otros lenguajes.

\subsubsection{Frontend: React vs frameworks alternativos}

La decisión de utilizar React se fundamentó en tres consideraciones técnicas principales:

\textbf{Gestión de estado para aplicaciones data-intensive:}
Las aplicaciones de visualización energética manejan grandes volúmenes de datos temporales que requieren re-renderizado eficiente. El Virtual DOM de React y su algoritmo de reconciliación optimizan específicamente este escenario, crucial para gráficos interactivos en tiempo real.

\textbf{Ecosistema de componentes de visualización:}
La disponibilidad de librerías especializadas como Recharts, D3-React integration, y Chart.js wrappers proporciona componentes específicamente diseñados para visualización de datos energéticos, evitando desarrollo custom de componentes complejos.

\textbf{TypeScript integration:}
La integración nativa con TypeScript permite type-safety en la manipulación de datos energéticos, crítico para prevenir errores en cálculos de coste y métricas ambientales que impactan directamente en la confiabilidad percibida por el usuario.

\section{Implementación del simulador IoT: desafíos y soluciones}

\subsection{Modelado realista de patrones de consumo}

El desarrollo del simulador IoT constituye una contribución técnica significativa, ya que debe reproducir fielmente los patrones estocásticos complejos observados en datos reales de consumo energético doméstico.

\subsubsection{Análisis de datos reales para calibración del modelo}

El proceso de calibración se basó en datasets públicos de consumo energético de 1,000+ hogares europeos (REFIT dataset, UK-DALE), permitiendo identificar patrones estadísticos robustos:

\textbf{Patrones diurnos con variabilidad estocástica:}
Los dispositivos exhiben consumo base determinístico modulado por componentes estocásticos que siguen distribuciones específicas según el tipo de dispositivo. Refrigeradores: distribución normal con ciclos determinísticos. Lavadoras: distribución bimodal relacionada con horarios humanos.

\textbf{Dependencias temporales complejas:}
El consumo presenta auto-correlación temporal con diferentes horizontes según el dispositivo. Climatización: correlación fuerte con temperatura exterior (lag 2-4 horas). Iluminación: correlación con horarios de sunset/sunrise estacionales.

\textbf{Eventos excepcionales y festividades:}
Los datos reales muestran desviaciones significativas durante eventos especiales (23% incremento promedio en períodos festivos), requiriendo modelado específico de calendar effects.

\subsection{Arquitectura del simulador: escalabilidad y realismo}

\begin{lstlisting}[caption=Arquitectura del simulador de dispositivos IoT]
backend/
|-- simulators/
|   |-- deviceSimulator.js      # Motor principal de simulación
|   |-- models/                 # Modelos específicos por dispositivo
|   |   |-- refrigerator.js     # Ciclos determinísticos + ruido
|   |   |-- washing_machine.js  # Eventos discretos programados
|   |   \-- hvac.js            # Modelo térmico simplificado
|   \-- patterns/               # Patrones calibrados
|       |-- daily_patterns.json
|       \-- seasonal_adjustments.json
\-- utils/
    \-- statistical_generators.js # Generadores estocásticos
\end{lstlisting}

\subsubsection{Implementación de modelos estocásticos calibrados}

El simulador implementa una arquitectura híbrida que combina modelos determinísticos para comportamientos predecibles con componentes estocásticos para variabilidad realista:

\textbf{Modelo de refrigerador:} Implementa un modelo térmico simplificado que simula ciclos de compresión basados en pérdidas térmicas del ambiente, modulado por ruido gaussiano calibrado (σ = 0.15 * consumo_base).

\textbf{Modelo de climatización:} Utiliza un modelo predictivo-correctivo que estima demanda térmica basada en diferencial interior-exterior, con factores de eficiencia variables según antigüedad simulada del equipo.

\textbf{Modelo de dispositivos programables:} Implementa máquinas de estado finito que simulan ciclos operacionales completos (lavado, secado, standby) con duraciones variables siguiendo distribuciones empíricamente calibradas.

\section{Sistema de machine learning: arquitectura y optimizaciones}

\subsection{Pipeline de datos para ML en tiempo real}

El diseño del pipeline de machine learning debía equilibrar precisión predictiva con latencia de respuesta, crítica para aplicaciones de tiempo real como detección de anomalías.

\subsubsection{Arquitectura de procesamiento distribuido}

La arquitectura implementa un modelo híbrido edge-cloud que optimiza el trade-off latencia-precisión:

\textbf{Procesamiento local (Edge):} Algoritmos ligeros para detección inmediata de anomalías evidentes (consumo > 3σ histórico) ejecutados en el frontend via WebWorkers, proporcionando feedback sub-segundo.

\textbf{Procesamiento en la nube:} Modelos complejos (LSTM, ensemble methods) ejecutados en el backend para predicciones de alta precisión, actualizados cada 15 minutos.

\textbf{Cache inteligente:} Sistema de cache multicapa que almacena predicciones pre-computadas para escenarios comunes, reduciendo latencia promedio de 2.3s a 150ms en consultas repetitivas.

\subsection{Optimizaciones específicas para datos energéticos}

\subsubsection{Feature engineering especializado}

El diseño de características específicas para datos energéticos representa una contribución técnica clave:

\textbf{Características temporales contextuales:} Más allá de timestamp básico, se incorporan características como "minutes_to_next_meal", "daylight_remaining", "weekend_proximity" que capturan patrones de comportamiento humano.

\textbf{Características de memoria adaptativa:} Implementación de ventanas deslizantes con pesos temporales que dan mayor importancia a patrones recientes, permitiendo adaptación a cambios de comportamiento del usuario.

\textbf{Características climáticas sintéticas:} Generación de características pseudo-meteorológicas correlacionadas con patrones de consumo estacionales, permitiendo simulación realista sin requerir APIs meteorológicas externas.

\begin{lstlisting}[language=JavaScript, caption=Configuración principal de Express]
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { sequelize } = require('./config/database');

const app = express();

// Middlewares de seguridad
app.use(helmet());
app.use(cors({
    origin: process.env.FRONTEND_URL || 'http://localhost:3000',
    credentials: true
}));

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 100 // máximo 100 requests por ventana
});
app.use(limiter);

// Parseo de JSON
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Rutas
app.use('/api/auth', require('./routes/auth'));
app.use('/api/devices', require('./routes/devices'));
app.use('/api/consumption', require('./routes/consumption'));

// Manejo de errores
app.use(require('./middleware/errorHandler'));

module.exports = app;
\end{lstlisting}

\subsection{Modelos de datos con Sequelize}

Los modelos implementados utilizan Sequelize ORM para la abstracción de la base de datos:

\subsubsection{Modelo de Usuario}

\begin{lstlisting}[language=JavaScript, caption=Modelo de Usuario]
const { DataTypes } = require('sequelize');
const bcrypt = require('bcryptjs');

const User = sequelize.define('User', {
    id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
    },
    email: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
        validate: {
            isEmail: true
        }
    },
    password: {
        type: DataTypes.STRING,
        allowNull: false,
        validate: {
            len: [8, 100]
        }
    },
    nombre: {
        type: DataTypes.STRING,
        allowNull: false
    },
    apellidos: {
        type: DataTypes.STRING
    },
    configuraciones: {
        type: DataTypes.JSONB,
        defaultValue: {}
    }
}, {
    hooks: {
        beforeCreate: async (user) => {
            user.password = await bcrypt.hash(user.password, 12);
        }
    }
});

User.prototype.checkPassword = async function(password) {
    return await bcrypt.compare(password, this.password);
};

module.exports = User;
\end{lstlisting}

\subsubsection{Modelo de Dispositivo}

\begin{lstlisting}[language=JavaScript, caption=Modelo de Dispositivo]
const Device = sequelize.define('Device', {
    id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        primaryKey: true
    },
    nombre: {
        type: DataTypes.STRING,
        allowNull: false
    },
    tipo: {
        type: DataTypes.ENUM(
            'refrigerator', 'washing_machine', 'dishwasher',
            'oven', 'tv', 'computer', 'ac_heating',
            'lighting', 'router', 'gaming_console', 'other'
        ),
        allowNull: false
    },
    potenciaNominal: {
        type: DataTypes.DECIMAL(10, 2),
        allowNull: false,
        validate: {
            min: 0
        }
    },
    ubicacion: {
        type: DataTypes.STRING
    },
    activo: {
        type: DataTypes.BOOLEAN,
        defaultValue: true
    },
    configuracion: {
        type: DataTypes.JSONB,
        defaultValue: {}
    }
});

// Relaciones
Device.belongsTo(User, { foreignKey: 'userId' });
User.hasMany(Device, { foreignKey: 'userId' });

module.exports = Device;
\end{lstlisting}

\subsection{Sistema de simulación IoT}

Una de las características más innovadoras del sistema es el simulador de datos IoT que genera información realista de consumo energético:

\begin{lstlisting}[language=JavaScript, caption=Simulador de dispositivos IoT]
class DeviceSimulator {
    constructor(device) {
        this.device = device;
        this.baseConsumption = device.potenciaNominal;
        this.patterns = this.loadConsumptionPatterns();
    }

    generateConsumption(timestamp) {
        const hour = timestamp.getHours();
        const dayOfWeek = timestamp.getDay();
        const month = timestamp.getMonth();

        // Factor base según el tipo de dispositivo
        let baseFactor = this.getBaseFactor(hour, dayOfWeek);
        
        // Factor estacional
        let seasonalFactor = this.getSeasonalFactor(month);
        
        // Variabilidad estocástica
        let randomFactor = 0.8 + Math.random() * 0.4;
        
        // Factor de eficiencia según la edad del dispositivo
        let efficiencyFactor = this.getEfficiencyFactor();

        const consumption = this.baseConsumption * 
                          baseFactor * 
                          seasonalFactor * 
                          randomFactor * 
                          efficiencyFactor;

        return {
            timestamp,
            potencia: Math.max(0, consumption),
            estado: this.determineDeviceState(consumption),
            factores: {
                base: baseFactor,
                estacional: seasonalFactor,
                aleatorio: randomFactor,
                eficiencia: efficiencyFactor
            }
        };
    }

    getBaseFactor(hour, dayOfWeek) {
        const patterns = {
            refrigerator: [0.8, 0.8, 0.8, 0.8, 0.9, 1.0, 1.1, 1.2,
                          1.1, 1.0, 1.0, 1.1, 1.2, 1.1, 1.0, 1.0,
                          1.1, 1.2, 1.3, 1.2, 1.1, 1.0, 0.9, 0.8],
            washing_machine: this.getWashingMachinePattern(hour, dayOfWeek),
            tv: this.getTVPattern(hour, dayOfWeek)
        };

        return patterns[this.device.tipo] || 
               patterns.refrigerator[hour] || 1.0;
    }

    getWashingMachinePattern(hour, dayOfWeek) {
        // Mayor uso en fines de semana y horarios específicos
        const weekendFactor = [0, 6].includes(dayOfWeek) ? 1.5 : 1.0;
        const hourlyPattern = hour >= 7 && hour <= 22 ? 1.0 : 0.1;
        const peakHours = [9, 10, 11, 15, 16, 17].includes(hour) ? 2.0 : 1.0;
        
        return weekendFactor * hourlyPattern * peakHours;
    }
}
\end{lstlisting}

\subsection{Sistema de autenticación JWT}

La implementación de autenticación utiliza JSON Web Tokens para gestionar sesiones:

\begin{lstlisting}[language=JavaScript, caption=Middleware de autenticación JWT]
const jwt = require('jsonwebtoken');
const User = require('../models/User');

const authMiddleware = async (req, res, next) => {
    try {
        const token = req.header('Authorization')?.replace('Bearer ', '');
        
        if (!token) {
            return res.status(401).json({
                success: false,
                message: 'Token de acceso requerido'
            });
        }

        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const user = await User.findByPk(decoded.userId);

        if (!user) {
            return res.status(401).json({
                success: false,
                message: 'Token inválido'
            });
        }

        req.user = user;
        next();
    } catch (error) {
        res.status(401).json({
            success: false,
            message: 'Token inválido',
            error: error.message
        });
    }
};

module.exports = authMiddleware;
\end{lstlisting}

\section{Implementación del frontend}

\subsection{Estructura y arquitectura React}

El frontend implementa una Single Page Application (SPA) utilizando React 18 con TypeScript, siguiendo principios de componentes reutilizables y gestión de estado centralizada:

\begin{lstlisting}[caption=Estructura del proyecto frontend]
frontend/
|-- public/
|   |-- index.html
|   \-- manifest.json
|-- src/
|   |-- components/         # Componentes reutilizables
|   |   |-- common/
|   |   |-- charts/
|   |   \-- forms/
|   |-- pages/             # Páginas principales
|   |   |-- Dashboard/
|   |   |-- Devices/
|   |   |-- Analysis/
|   |   \-- Settings/
|   |-- contexts/          # Context API para estado global
|   |   |-- AuthContext.tsx
|   |   \-- ThemeContext.tsx
|   |-- services/          # Servicios para APIs
|   |   |-- api.ts
|   |   |-- authService.ts
|   |   \-- deviceService.ts
|   |-- utils/             # Utilidades y helpers
|   |   |-- formatters.ts
|   |   \-- validators.ts
|   |-- types/             # Definiciones TypeScript
|   |   \-- index.ts
|   |-- App.tsx           # Componente principal
|   \-- index.tsx         # Punto de entrada
\-- package.json
\end{lstlisting}

\subsection{Gestión de estado con Context API}

Para la gestión de estado global se utiliza React Context API, evitando la complejidad de Redux para un proyecto de este tamaño:

\begin{lstlisting}[language=TypeScript, caption=Context de autenticación]
interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => void;
  register: (userData: RegisterData) => Promise<void>;
}

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ 
  children 
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const token = localStorage.getItem('authToken');
    if (token) {
      validateToken(token);
    } else {
      setLoading(false);
    }
  }, []);

  const login = async (email: string, password: string) => {
    try {
      const response = await authService.login(email, password);
      const { user, token } = response.data;
      
      localStorage.setItem('authToken', token);
      setUser(user);
    } catch (error) {
      throw new Error('Credenciales inválidas');
    }
  };

  const logout = () => {
    localStorage.removeItem('authToken');
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{
      user,
      loading,
      login,
      logout,
      register
    }}>
      {children}
    </AuthContext.Provider>
  );
};
\end{lstlisting}

\subsection{Componentes de visualización}

Los componentes de visualización utilizan Chart.js para crear gráficos interactivos:

\begin{lstlisting}[language=TypeScript, caption=Componente de gráfico de consumo]
interface ConsumptionChartProps {
  data: ConsumptionData[];
  timeRange: TimeRange;
  deviceFilter?: string;
}

const ConsumptionChart: React.FC<ConsumptionChartProps> = ({
  data,
  timeRange,
  deviceFilter
}) => {
  const chartData = useMemo(() => {
    const filteredData = deviceFilter 
      ? data.filter(d => d.deviceId === deviceFilter)
      : data;

    return {
      labels: filteredData.map(d => 
        format(new Date(d.timestamp), 'HH:mm')
      ),
      datasets: [{
        label: 'Consumo (kW)',
        data: filteredData.map(d => d.potencia / 1000),
        borderColor: 'rgb(75, 192, 192)',
        backgroundColor: 'rgba(75, 192, 192, 0.2)',
        tension: 0.1
      }]
    };
  }, [data, deviceFilter]);

  const options: ChartOptions<'line'> = {
    responsive: true,
    plugins: {
      legend: {
        position: 'top' as const,
      },
      title: {
        display: true,
        text: 'Consumo Energetico en Tiempo Real'
      },
      tooltip: {
        callbacks: {
          label: (context) => {
            const value = context.parsed.y;
            const cost = value * 0.15; // EURO/kWh
            return [
              `Consumo: ${value.toFixed(2)} kW`,
              `Coste: EURO\${cost.toFixed(3)}`
            ];
          }
        }
      }
    },
    scales: {
      x: {
        display: true,
        title: {
          display: true,
          text: 'Tiempo'
        }
      },
      y: {
        display: true,
        title: {
          display: true,
          text: 'Consumo (kW)'
        },
        min: 0
      }
    }
  };

  return (
    <Card>
      <CardContent>
        <Line data={chartData} options={options} />
      </CardContent>
    </Card>
  );
};
\end{lstlisting}

\subsection{Responsive design con Material-UI}

La interfaz utiliza Material-UI (MUI) para garantizar un diseño responsive y consistente:

\begin{lstlisting}[language=TypeScript, caption=Dashboard responsive]
const Dashboard: React.FC = () => {
  const { user } = useAuth();
  const [consumptionData, setConsumptionData] = useState<ConsumptionData[]>([]);
  const [devices, setDevices] = useState<Device[]>([]);

  return (
    <Container maxWidth="xl">
      <Typography variant="h4" gutterBottom>
        Dashboard - {user?.nombre}
      </Typography>
      
      <Grid container spacing={3}>
        {/* Metricas principales */}
        <Grid item xs={12} sm={6} md={3}>
          <MetricCard
            title="Consumo Actual"
            value={currentConsumption}
            unit="kW"
            icon={<ElectricBoltIcon />}
            color="primary"
          />
        </Grid>
        
        <Grid item xs={12} sm={6} md={3}>
          <MetricCard
            title="Consumo Hoy"
            value={todayConsumption}
            unit="kWh"
            icon={<TodayIcon />}
            color="secondary"
          />
        </Grid>
        
        <Grid item xs={12} sm={6} md={3}>
          <MetricCard
            title="Coste Estimado"
            value={estimatedCost}
            unit="EURO"
            icon={<EuroIcon />}
            color="success"
          />
        </Grid>
        
        <Grid item xs={12} sm={6} md={3}>
          <MetricCard
            title="Eficiencia"
            value={efficiency}
            unit="%"
            icon={<EcoIcon />}
            color="info"
          />
        </Grid>

        {/* Grafico principal */}
        <Grid item xs={12} lg={8}>
          <ConsumptionChart
            data={consumptionData}
            timeRange="24h"
          />
        </Grid>

        {/* Lista de dispositivos */}
        <Grid item xs={12} lg={4}>
          <DeviceList devices={devices} />
        </Grid>

        {/* Predicciones */}
        <Grid item xs={12} md={6}>
          <PredictionChart />
        </Grid>

        {/* Alertas recientes */}
        <Grid item xs={12} md={6}>
          <RecentAlerts />
        </Grid>
      </Grid>
    </Container>
  );
};
\end{lstlisting}

\section{Implementación de modelos de Machine Learning}

\subsection{Arquitectura del servicio ML}

El servicio de Machine Learning está implementado como una API independiente en Python utilizando Flask:

\begin{lstlisting}[language=Python, caption=Estructura del servicio ML]
from flask import Flask, request, jsonify
from flask_cors import CORS
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
import joblib
import logging

app = Flask(__name__)
CORS(app)

class EnergyPredictor:
    def __init__(self):
        self.models = {
            'random_forest': RandomForestRegressor(
                n_estimators=100,
                random_state=42,
                n_jobs=-1
            ),
            'gradient_boosting': GradientBoostingRegressor(
                n_estimators=100,
                learning_rate=0.1,
                random_state=42
            )
        }
        self.scaler = StandardScaler()
        self.is_trained = False
        
    def prepare_features(self, data):
        """Prepara caracteristicas para el modelo"""
        df = pd.DataFrame(data)
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        
        # Caracteristicas temporales
        df['hour'] = df['timestamp'].dt.hour
        df['day_of_week'] = df['timestamp'].dt.dayofweek
        df['month'] = df['timestamp'].dt.month
        df['is_weekend'] = df['day_of_week'].isin([5, 6]).astype(int)
        
        # Caracteristicas de lag
        df['consumption_lag_1'] = df['potencia'].shift(1)
        df['consumption_lag_24'] = df['potencia'].shift(24)
        df['consumption_lag_168'] = df['potencia'].shift(168)  # 1 semana
        
        # Caracteristicas estadisticas moviles
        df['consumption_mean_24h'] = df['potencia'].rolling(24).mean()
        df['consumption_std_24h'] = df['potencia'].rolling(24).std()
        
        return df.fillna(method='bfill').fillna(method='ffill')
\end{lstlisting}

\subsection{Algoritmos de predicción implementados}

\subsubsection{Random Forest para predicción a corto plazo}

\begin{lstlisting}[language=Python, caption=Implementación Random Forest]
def train_random_forest(self, X, y):
    """Entrena el modelo Random Forest"""
    X_scaled = self.scaler.fit_transform(X)
    
    self.models['random_forest'].fit(X_scaled, y)
    
    # Validacion cruzada
    from sklearn.model_selection import cross_val_score
    scores = cross_val_score(
        self.models['random_forest'], 
        X_scaled, y, 
        cv=5, 
        scoring='neg_mean_absolute_error'
    )
    
    return {
        'model': 'random_forest',
        'cv_score': -scores.mean(),
        'cv_std': scores.std(),
        'feature_importance': dict(zip(
            X.columns, 
            self.models['random_forest'].feature_importances_
        ))
    }

def predict_consumption(self, features, model_type='random_forest'):
    """Realiza prediccion de consumo"""
    if not self.is_trained:
        raise ValueError("El modelo debe ser entrenado primero")
    
    features_scaled = self.scaler.transform(features)
    prediction = self.models[model_type].predict(features_scaled)
    
    # Calcular intervalo de confianza usando bootstrap
    confidence_interval = self._calculate_confidence_interval(
        features_scaled, model_type
    )
    
    return {
        'prediction': prediction.tolist(),
        'confidence_lower': confidence_interval['lower'].tolist(),
        'confidence_upper': confidence_interval['upper'].tolist(),
        'model_used': model_type
    }
\end{lstlisting}

\subsubsection{Detección de anomalías}

\begin{lstlisting}[language=Python, caption=Sistema de detección de anomalías]
from sklearn.ensemble import IsolationForest
from scipy.stats import zscore

class AnomalyDetector:
    def __init__(self):
        self.isolation_forest = IsolationForest(
            contamination=0.1,
            random_state=42
        )
        self.statistical_threshold = 3  # Z-score threshold
        
    def detect_anomalies(self, consumption_data):
        """Detecta anomalias en los datos de consumo"""
        df = pd.DataFrame(consumption_data)
        
        # Metodo 1: Isolation Forest
        isolation_scores = self.isolation_forest.fit_predict(
            df[['potencia']].values
        )
        
        # Metodo 2: Z-score estadistico
        z_scores = np.abs(zscore(df['potencia']))
        statistical_anomalies = z_scores > self.statistical_threshold
        
        # Metodo 3: Analisis temporal
        temporal_anomalies = self._detect_temporal_anomalies(df)
        
        # Combinar resultados
        anomalies = []
        for i, row in df.iterrows():
            is_anomaly = (
                isolation_scores[i] == -1 or 
                statistical_anomalies[i] or 
                temporal_anomalies[i]
            )
            
            if is_anomaly:
                anomalies.append({
                    'timestamp': row['timestamp'],
                    'consumption': row['potencia'],
                    'anomaly_type': self._classify_anomaly_type(
                        isolation_scores[i], 
                        statistical_anomalies[i], 
                        temporal_anomalies[i]
                    ),
                    'severity': self._calculate_severity(row['potencia'], df)
                })
        
        return anomalies
    
    def _detect_temporal_anomalies(self, df):
        """Detecta anomalias basadas en patrones temporales"""
        df['hour'] = pd.to_datetime(df['timestamp']).dt.hour
        
        # Calcular consumo promedio por hora
        hourly_means = df.groupby('hour')['potencia'].mean()
        hourly_stds = df.groupby('hour')['potencia'].std()
        
        anomalies = []
        for _, row in df.iterrows():
            hour = pd.to_datetime(row['timestamp']).hour
            expected = hourly_means[hour]
            std_dev = hourly_stds[hour]
            
            # Si el consumo esta fuera de 2 desviaciones estandar
            anomalies.append(
                abs(row['potencia'] - expected) > 2 * std_dev
            )
        
        return anomalies
\end{lstlisting}

\subsection{API endpoints del servicio ML}

\begin{lstlisting}[language=Python, caption=Endpoints de la API ML]
@app.route('/predict', methods=['POST'])
def predict_consumption():
    try:
        data = request.get_json()
        
        # Validar datos de entrada
        required_fields = ['historical_data', 'features']
        if not all(field in data for field in required_fields):
            return jsonify({
                'error': 'Campos requeridos faltantes'
            }), 400
        
        # Preparar caracteristicas
        features_df = predictor.prepare_features(data['historical_data'])
        
        # Realizar prediccion
        prediction_result = predictor.predict_consumption(
            features_df, 
            model_type=data.get('model_type', 'random_forest')
        )
        
        return jsonify({
            'success': True,
            'prediction': prediction_result,
            'timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logging.error(f"Error en prediccion: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/detect-anomalies', methods=['POST'])
def detect_anomalies():
    try:
        data = request.get_json()
        
        anomalies = anomaly_detector.detect_anomalies(
            data['consumption_data']
        )
        
        return jsonify({
            'success': True,
            'anomalies': anomalies,
            'total_anomalies': len(anomalies),
            'analysis_timestamp': datetime.now().isoformat()
        })
        
    except Exception as e:
        logging.error(f"Error en deteccion de anomalias: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/model-metrics', methods=['GET'])
def get_model_metrics():
    """Devuelve metricas de rendimiento de los modelos"""
    if not predictor.is_trained:
        return jsonify({
            'error': 'Modelos no entrenados'
        }), 400
    
    return jsonify({
        'success': True,
        'metrics': predictor.get_model_metrics(),
        'last_training': predictor.last_training_time
    })
\end{lstlisting}

\section{Integración y testing}

\subsection{Testing del backend}

Se implementan tests unitarios e integración utilizando Jest y Supertest:

\begin{lstlisting}[language=JavaScript, caption=Tests de la API de autenticación]
const request = require('supertest');
const app = require('../app');
const { User } = require('../models');

describe('Authentication API', () => {
    beforeEach(async () => {
        await User.destroy({ where: {} });
    });

    describe('POST /api/auth/register', () => {
        it('deberia registrar un nuevo usuario', async () => {
            const userData = {
                email: 'test@example.com',
                password: 'password123',
                nombre: 'Test',
                apellidos: 'User'
            };

            const response = await request(app)
                .post('/api/auth/register')
                .send(userData)
                .expect(201);

            expect(response.body.success).toBe(true);
            expect(response.body.user.email).toBe(userData.email);
            expect(response.body.token).toBeDefined();
        });

        it('deberia fallar con email invalido', async () => {
            const userData = {
                email: 'invalid-email',
                password: 'password123',
                nombre: 'Test'
            };

            const response = await request(app)
                .post('/api/auth/register')
                .send(userData)
                .expect(400);

            expect(response.body.success).toBe(false);
        });
    });

    describe('POST /api/auth/login', () => {
        beforeEach(async () => {
            await User.create({
                email: 'test@example.com',
                password: 'password123',
                nombre: 'Test'
            });
        });

        it('deberia autenticar usuario valido', async () => {
            const response = await request(app)
                .post('/api/auth/login')
                .send({
                    email: 'test@example.com',
                    password: 'password123'
                })
                .expect(200);

            expect(response.body.success).toBe(true);
            expect(response.body.token).toBeDefined();
        });
    });
});
\end{lstlisting}

\subsection{Testing del frontend}

Tests de componentes React utilizando React Testing Library:

\begin{lstlisting}[language=TypeScript, caption=Tests de componentes React]
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { AuthProvider } from '../contexts/AuthContext';
import LoginForm from '../components/LoginForm';

const renderWithAuth = (component: React.ReactElement) => {
  return render(
    <AuthProvider>
      {component}
    </AuthProvider>
  );
};

describe('LoginForm', () => {
  it('deberia renderizar formulario de login', () => {
    renderWithAuth(<LoginForm />);
    
    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/contrasena/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /iniciar sesion/i }))
      .toBeInTheDocument();
  });

  it('deberia validar campos requeridos', async () => {
    renderWithAuth(<LoginForm />);
    
    const submitButton = screen.getByRole('button', { name: /iniciar sesión/i });
    fireEvent.click(submitButton);

    await waitFor(() => {
      expect(screen.getByText(/email es requerido/i)).toBeInTheDocument();
      expect(screen.getByText(/contrasena es requerida/i)).toBeInTheDocument();
    });
  });

  it('deberia enviar datos validos', async () => {
    const mockLogin = jest.fn();
    
    renderWithAuth(<LoginForm onLogin={mockLogin} />);
    
    fireEvent.change(screen.getByLabelText(/email/i), {
      target: { value: 'test@example.com' }
    });
    fireEvent.change(screen.getByLabelText(/contrasena/i), {
      target: { value: 'password123' }
    });
    
    fireEvent.click(screen.getByRole('button', { name: /iniciar sesion/i }));

    await waitFor(() => {
      expect(mockLogin).toHaveBeenCalledWith({
        email: 'test@example.com',
        password: 'password123'
      });
    });
  });
});
\end{lstlisting}

\section{Conclusiones del capítulo}

En este capítulo se ha detallado la implementación técnica completa de EnergiApp, cubriendo:

\begin{itemize}
    \item \textbf{Backend robusto:} API RESTful con Node.js/Express, autenticación JWT, y simulación IoT avanzada
    \item \textbf{Frontend moderno:} SPA con React/TypeScript, visualizaciones interactivas y diseño responsive
    \item \textbf{Machine Learning aplicado:} Modelos predictivos y detección de anomalías con Python/scikit-learn
    \item \textbf{Testing exhaustivo:} Cobertura de tests unitarios e integración para garantizar calidad
    \item \textbf{Arquitectura escalable:} Diseño modular que facilita mantenimiento y futuras extensiones
\end{itemize}

La implementación demuestra la aplicación práctica de tecnologías modernas para resolver un problema real de sostenibilidad energética, cumpliendo todos los objetivos técnicos establecidos.
